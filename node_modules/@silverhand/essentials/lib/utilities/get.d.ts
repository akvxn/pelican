type ValidKeys<T> = keyof T extends string ? keyof T : never;
export type KeySerial<T extends Record<string, unknown>> = ValidKeys<T> | {
    [key in ValidKeys<T>]: T[key] extends unknown[] ? never : T[key] extends Record<string, unknown> ? `${key}.${KeySerial<T[key]>}` : never;
}[ValidKeys<T>];
export type ExtractKeySerialType<T extends Record<string, unknown>, Serial extends string> = Serial extends `${infer Key}.${infer Rest}` ? T[Key] extends Record<string, unknown> ? ExtractKeySerialType<T[Key], Rest> : never : T[Serial];
type Get = {
    <T extends Record<string, unknown>, Serial extends KeySerial<T>>(object: T, keySerial: Serial): ExtractKeySerialType<T, Serial>;
    (object: unknown, keySerial: string): unknown;
};
export declare const get: Get;
export declare const getSafe: Get;
/** Same to `get()` but with the strict type definition only to enable IntelliSense. */
export declare const getValue: <T extends Record<string, unknown>, Serial extends KeySerial<T>>(object: T, keySerial: Serial) => ExtractKeySerialType<T, Serial>;
export {};
