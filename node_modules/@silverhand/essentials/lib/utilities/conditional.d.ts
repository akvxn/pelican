import type { Falsy, Nullable, Optional, Truthy } from './types.js';
export declare const nullable: <T>(exp: T) => Nullable<Truthy<T>>;
/**
 * Conditional return the expression result when it's not {@link Falsy};
 * otherwise return `undefined`.
 *
 * @example
 * ```ts
 * conditional(1 && '2') // '2'
 * conditional(false && '1') // undefined
 * ```
 */
export declare const conditional: <T>(exp: T) => Optional<Truthy<T>>;
/** Alias for {@link conditional}. */
export declare const cond: <T>(exp: T) => Optional<Truthy<T>>;
/**
 * Conditional return the stringified expression result (using `String`) when it's not {@link Falsy};
 * otherwise return an empty string.
 *
 * @example
 * ```ts
 * conditionalString(1 && 2) // '2'
 * conditionalString(false && '1') // ''
 * ```
 */
export declare const conditionalString: <T>(exp: T) => string;
/** Alias for {@link conditionalString}. */
export declare const condString: <T>(exp: T) => string;
/**
 * Conditional concat multiple expression results into a array by filtering all {@link Falsy} results
 * and flatten 1 level deep if the expression result is an array.
 *
 * @example
 * ```ts
 * conditionalArray(1, [2, 3]) // [1, 2, 3]
 * ```
 */
export declare const conditionalArray: <T>(...exps: readonly (Falsy | T)[]) => (T extends readonly (infer InnerArray)[] ? InnerArray : T)[];
/** Alias for {@link conditionalArray}. */
export declare const condArray: <T>(...exps: readonly (Falsy | T)[]) => (T extends readonly (infer InnerArray)[] ? InnerArray : T)[];
/**
 * An object with all {@link Falsy} values removed while keeping the object structure.
 * Note `undefined` definitions are not removed from the object in some conditions
 * because it's uncertain whether the value is falsy or not.
 */
export type TruthyObject<T extends Record<string, unknown>> = {
    [K in keyof T as T[K] extends Falsy ? never : K]: [T[K] & Falsy] extends [never] ? T[K] : Optional<Truthy<T[K]>>;
};
/**
 * Return a new object with all {@link Falsy} values removed.
 * This function only performs a shallow removal, i.e. it does not remove
 * {@link Falsy} values nested in objects.
 *
 * @example
 * ```ts
 * conditionalObject({
 *   foo: 'foo',
 *   bar: undefined,
 *   baz: false,
 * }) // { foo: 'foo' }
 * ```
 */
export declare const conditionalObject: <T extends Record<string, unknown>>(object: T) => TruthyObject<T>;
/** Alias for {@link conditionalObject}. */
export declare const condObject: <T extends Record<string, unknown>>(object: T) => TruthyObject<T>;
