import { trySafe, conditional } from '@silverhand/essentials';
export { CacheKey, PersistKey } from './types.js';

class ClientAdapterInstance {
    /* END OF IMPLEMENTATION */
    constructor(adapter) {
        // eslint-disable-next-line @silverhand/fp/no-mutating-assign
        Object.assign(this, adapter);
    }
    async setStorageItem(key, value) {
        if (!value) {
            await this.storage.removeItem(key);
            return;
        }
        await this.storage.setItem(key, value);
    }
    /**
     * Try to get the string value from the cache and parse as JSON.
     * Return the parsed value if it is an object, return `undefined` otherwise.
     *
     * @param key The cache key to get value from.
     */
    async getCachedObject(key) {
        const cached = await trySafe(async () => {
            const data = await this.unstable_cache?.getItem(key);
            // It's actually `unknown`
            // eslint-disable-next-line no-restricted-syntax
            return conditional(data && JSON.parse(data));
        });
        if (cached && typeof cached === 'object') {
            // Trust cache for now
            // eslint-disable-next-line no-restricted-syntax
            return cached;
        }
    }
    /**
     * Try to get the value from the cache first, if it doesn't exist in cache,
     * run the getter function and store the result into cache.
     *
     * @param key The cache key to get value from.
     */
    async getWithCache(key, getter) {
        const cached = await this.getCachedObject(key);
        if (cached) {
            return cached;
        }
        const result = await getter();
        await this.unstable_cache?.setItem(key, JSON.stringify(result));
        return result;
    }
}

export { ClientAdapterInstance };
